/*
 * generated by Xtext 2.10.0
 */
package org.metaborg.paplj.scoping

import org.metaborg.paplj.paplj.MemberRef
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.metaborg.paplj.types.PapljTypeProvider
import com.google.inject.Inject
import static extension org.metaborg.paplj.PapljModelUtil.*
import org.eclipse.xtext.scoping.Scopes
import org.metaborg.paplj.paplj.Type
import org.metaborg.paplj.paplj.Var
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.metaborg.paplj.paplj.Let
import org.metaborg.paplj.paplj.Expr

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class PapljScopeProvider extends AbstractPapljScopeProvider {

	// NOTE: These method names work by convention.
	
	@Inject extension PapljTypeProvider
	
	def scope_Symbol(Var ref, EReference r) {
		val type = ref.getContainerOfType(typeof(Type))	// implicit `this`
		val scope = getScopesForClasses(IScope::NULLSCOPE, type, ref.methodInvocation)
		val newScope = getScopesForBindings(scope, ref)
		newScope
	}
	
	def scope_Member(MemberRef ref, EReference r) {
		val type = ref.left.typeOf
		val scope = getScopesForClasses(IScope::NULLSCOPE, type, ref.methodInvocation)
		scope
	}
	
	def getScopesForClasses(IScope baseScope, Type type, boolean isMethodInvocation) {
		var scope = baseScope
		
		if (type === null)
			return scope
		for (c : type.ancestors.reverseView) {
			// Override the previous scope with a new scope for the parent type.
			scope = Scopes::scopeFor(c.selectMembers(isMethodInvocation),
				scope
			)
		}
		// Override the previous scope with a new scope for this type.
		Scopes::scopeFor(type.selectMembers(isMethodInvocation), scope)
	}
	
	def selectMembers(Type type, boolean isMethodInvocation) {
		if (isMethodInvocation)
			// For a method invocation we primarily resolve to methods,
			// and secondarily to fields (so we can give a more descriptive
			// error other than 'reference not found').
			type.methods + type.fields
		else
			// For a field reference we primarily resolve to fields,
			// and secondarily to methods (so we can give a more descritive
			// error other than 'reference not found').
			type.fields + type.methods
	}
	
	def getScopesForBindings(IScope baseScope, Expr e) {
		var scope = baseScope
		
		if (e === null)
			return scope
		for (l : e.lets.reverseView) {
			// Override the previous scope with a new scope for the parent type.
			scope = Scopes::scopeFor(l.selectBindings(),
				scope
			)
		}
		
		scope
	}

	def selectBindings(Let let) {
		let.bindings
	}
}