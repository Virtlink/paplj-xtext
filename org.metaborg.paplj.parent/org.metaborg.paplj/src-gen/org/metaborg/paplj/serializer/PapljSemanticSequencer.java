/*
 * generated by Xtext 2.11.0
 */
package org.metaborg.paplj.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.metaborg.paplj.paplj.Add;
import org.metaborg.paplj.paplj.And;
import org.metaborg.paplj.paplj.Assignment;
import org.metaborg.paplj.paplj.Binding;
import org.metaborg.paplj.paplj.Block2;
import org.metaborg.paplj.paplj.Bool;
import org.metaborg.paplj.paplj.Cast;
import org.metaborg.paplj.paplj.Div;
import org.metaborg.paplj.paplj.Eq;
import org.metaborg.paplj.paplj.Field;
import org.metaborg.paplj.paplj.If;
import org.metaborg.paplj.paplj.Import;
import org.metaborg.paplj.paplj.Let;
import org.metaborg.paplj.paplj.Lt;
import org.metaborg.paplj.paplj.MemberRef;
import org.metaborg.paplj.paplj.Method;
import org.metaborg.paplj.paplj.Min;
import org.metaborg.paplj.paplj.Mul;
import org.metaborg.paplj.paplj.Neq;
import org.metaborg.paplj.paplj.New;
import org.metaborg.paplj.paplj.Not;
import org.metaborg.paplj.paplj.Null;
import org.metaborg.paplj.paplj.Num;
import org.metaborg.paplj.paplj.Or;
import org.metaborg.paplj.paplj.PapljPackage;
import org.metaborg.paplj.paplj.Param;
import org.metaborg.paplj.paplj.Program;
import org.metaborg.paplj.paplj.Sub;
import org.metaborg.paplj.paplj.This;
import org.metaborg.paplj.paplj.Type;
import org.metaborg.paplj.paplj.Var;
import org.metaborg.paplj.services.PapljGrammarAccess;

@SuppressWarnings("all")
public class PapljSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PapljGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PapljPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PapljPackage.ADD:
				sequence_AdditiveExpr(context, (Add) semanticObject); 
				return; 
			case PapljPackage.AND:
				sequence_LogicalAndExpr(context, (And) semanticObject); 
				return; 
			case PapljPackage.ASSIGNMENT:
				sequence_AssignmentExpr(context, (Assignment) semanticObject); 
				return; 
			case PapljPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case PapljPackage.BLOCK2:
				sequence_Block2(context, (Block2) semanticObject); 
				return; 
			case PapljPackage.BOOL:
				sequence_PrimaryExpr(context, (Bool) semanticObject); 
				return; 
			case PapljPackage.CAST:
				sequence_UnaryExpr(context, (Cast) semanticObject); 
				return; 
			case PapljPackage.DIV:
				sequence_MultiplicativeExpr(context, (Div) semanticObject); 
				return; 
			case PapljPackage.EQ:
				sequence_ComparativeExpr(context, (Eq) semanticObject); 
				return; 
			case PapljPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case PapljPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case PapljPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case PapljPackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case PapljPackage.LT:
				sequence_ComparativeExpr(context, (Lt) semanticObject); 
				return; 
			case PapljPackage.MEMBER_REF:
				sequence_MemberExpr(context, (MemberRef) semanticObject); 
				return; 
			case PapljPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case PapljPackage.MIN:
				sequence_UnaryExpr(context, (Min) semanticObject); 
				return; 
			case PapljPackage.MUL:
				sequence_MultiplicativeExpr(context, (Mul) semanticObject); 
				return; 
			case PapljPackage.NEQ:
				sequence_ComparativeExpr(context, (Neq) semanticObject); 
				return; 
			case PapljPackage.NEW:
				sequence_PrimaryExpr(context, (New) semanticObject); 
				return; 
			case PapljPackage.NOT:
				sequence_UnaryExpr(context, (Not) semanticObject); 
				return; 
			case PapljPackage.NULL:
				sequence_PrimaryExpr(context, (Null) semanticObject); 
				return; 
			case PapljPackage.NUM:
				sequence_PrimaryExpr(context, (Num) semanticObject); 
				return; 
			case PapljPackage.OR:
				sequence_LogicalOrExpr(context, (Or) semanticObject); 
				return; 
			case PapljPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case PapljPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PapljPackage.SUB:
				sequence_AdditiveExpr(context, (Sub) semanticObject); 
				return; 
			case PapljPackage.THIS:
				sequence_PrimaryExpr(context, (This) semanticObject); 
				return; 
			case PapljPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case PapljPackage.VAR:
				sequence_PrimaryExpr(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expr returns Add
	 *     IfLetExpr returns Add
	 *     AssignmentExpr returns Add
	 *     AssignmentExpr.Assignment_1_0_0 returns Add
	 *     LogicalOrExpr returns Add
	 *     LogicalOrExpr.Or_1_0_0 returns Add
	 *     LogicalAndExpr returns Add
	 *     LogicalAndExpr.And_1_0_0 returns Add
	 *     ComparativeExpr returns Add
	 *     ComparativeExpr.Eq_1_0_0_0 returns Add
	 *     ComparativeExpr.Neq_1_0_1_0 returns Add
	 *     ComparativeExpr.Lt_1_0_2_0 returns Add
	 *     AdditiveExpr returns Add
	 *     AdditiveExpr.Add_1_0_0_0 returns Add
	 *     AdditiveExpr.Sub_1_0_1_0 returns Add
	 *     MultiplicativeExpr returns Add
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Add
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Add
	 *     UnaryExpr returns Add
	 *     UnaryExpr.Cast_0_1_0_0 returns Add
	 *     MemberExpr returns Add
	 *     MemberExpr.MemberRef_1_0_0 returns Add
	 *     PrimaryExpr returns Add
	 *
	 * Constraint:
	 *     (left=AdditiveExpr_Add_1_0_0_0 right=MultiplicativeExpr)
	 */
	protected void sequence_AdditiveExpr(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.ADD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.ADD__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.ADD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.ADD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExprAccess().getAddLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExprAccess().getRightMultiplicativeExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Sub
	 *     IfLetExpr returns Sub
	 *     AssignmentExpr returns Sub
	 *     AssignmentExpr.Assignment_1_0_0 returns Sub
	 *     LogicalOrExpr returns Sub
	 *     LogicalOrExpr.Or_1_0_0 returns Sub
	 *     LogicalAndExpr returns Sub
	 *     LogicalAndExpr.And_1_0_0 returns Sub
	 *     ComparativeExpr returns Sub
	 *     ComparativeExpr.Eq_1_0_0_0 returns Sub
	 *     ComparativeExpr.Neq_1_0_1_0 returns Sub
	 *     ComparativeExpr.Lt_1_0_2_0 returns Sub
	 *     AdditiveExpr returns Sub
	 *     AdditiveExpr.Add_1_0_0_0 returns Sub
	 *     AdditiveExpr.Sub_1_0_1_0 returns Sub
	 *     MultiplicativeExpr returns Sub
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Sub
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Sub
	 *     UnaryExpr returns Sub
	 *     UnaryExpr.Cast_0_1_0_0 returns Sub
	 *     MemberExpr returns Sub
	 *     MemberExpr.MemberRef_1_0_0 returns Sub
	 *     PrimaryExpr returns Sub
	 *
	 * Constraint:
	 *     (left=AdditiveExpr_Sub_1_0_1_0 right=MultiplicativeExpr)
	 */
	protected void sequence_AdditiveExpr(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SUB__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SUB__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SUB__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SUB__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExprAccess().getSubLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExprAccess().getRightMultiplicativeExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Assignment
	 *     IfLetExpr returns Assignment
	 *     AssignmentExpr returns Assignment
	 *     AssignmentExpr.Assignment_1_0_0 returns Assignment
	 *     LogicalOrExpr returns Assignment
	 *     LogicalOrExpr.Or_1_0_0 returns Assignment
	 *     LogicalAndExpr returns Assignment
	 *     LogicalAndExpr.And_1_0_0 returns Assignment
	 *     ComparativeExpr returns Assignment
	 *     ComparativeExpr.Eq_1_0_0_0 returns Assignment
	 *     ComparativeExpr.Neq_1_0_1_0 returns Assignment
	 *     ComparativeExpr.Lt_1_0_2_0 returns Assignment
	 *     AdditiveExpr returns Assignment
	 *     AdditiveExpr.Add_1_0_0_0 returns Assignment
	 *     AdditiveExpr.Sub_1_0_1_0 returns Assignment
	 *     MultiplicativeExpr returns Assignment
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Assignment
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Assignment
	 *     UnaryExpr returns Assignment
	 *     UnaryExpr.Cast_0_1_0_0 returns Assignment
	 *     MemberExpr returns Assignment
	 *     MemberExpr.MemberRef_1_0_0 returns Assignment
	 *     PrimaryExpr returns Assignment
	 *
	 * Constraint:
	 *     (left=AssignmentExpr_Assignment_1_0_0 value=Expr)
	 */
	protected void sequence_AssignmentExpr(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExprAccess().getAssignmentLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExprAccess().getValueExprParserRuleCall_1_0_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Binding
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] name=ID value=Expr)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__NAME));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.BINDING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.BINDING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getTypeTypeQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(PapljPackage.Literals.SYMBOL__TYPE, false));
		feeder.accept(grammarAccess.getBindingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBindingAccess().getValueExprParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block2 returns Block2
	 *     Expr returns Block2
	 *     IfLetExpr returns Block2
	 *     AssignmentExpr returns Block2
	 *     AssignmentExpr.Assignment_1_0_0 returns Block2
	 *     LogicalOrExpr returns Block2
	 *     LogicalOrExpr.Or_1_0_0 returns Block2
	 *     LogicalAndExpr returns Block2
	 *     LogicalAndExpr.And_1_0_0 returns Block2
	 *     ComparativeExpr returns Block2
	 *     ComparativeExpr.Eq_1_0_0_0 returns Block2
	 *     ComparativeExpr.Neq_1_0_1_0 returns Block2
	 *     ComparativeExpr.Lt_1_0_2_0 returns Block2
	 *     AdditiveExpr returns Block2
	 *     AdditiveExpr.Add_1_0_0_0 returns Block2
	 *     AdditiveExpr.Sub_1_0_1_0 returns Block2
	 *     MultiplicativeExpr returns Block2
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Block2
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Block2
	 *     UnaryExpr returns Block2
	 *     UnaryExpr.Cast_0_1_0_0 returns Block2
	 *     MemberExpr returns Block2
	 *     MemberExpr.MemberRef_1_0_0 returns Block2
	 *     PrimaryExpr returns Block2
	 *
	 * Constraint:
	 *     (exprs+=Expr exprs+=Expr*)?
	 */
	protected void sequence_Block2(ISerializationContext context, Block2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Eq
	 *     IfLetExpr returns Eq
	 *     AssignmentExpr returns Eq
	 *     AssignmentExpr.Assignment_1_0_0 returns Eq
	 *     LogicalOrExpr returns Eq
	 *     LogicalOrExpr.Or_1_0_0 returns Eq
	 *     LogicalAndExpr returns Eq
	 *     LogicalAndExpr.And_1_0_0 returns Eq
	 *     ComparativeExpr returns Eq
	 *     ComparativeExpr.Eq_1_0_0_0 returns Eq
	 *     ComparativeExpr.Neq_1_0_1_0 returns Eq
	 *     ComparativeExpr.Lt_1_0_2_0 returns Eq
	 *     AdditiveExpr returns Eq
	 *     AdditiveExpr.Add_1_0_0_0 returns Eq
	 *     AdditiveExpr.Sub_1_0_1_0 returns Eq
	 *     MultiplicativeExpr returns Eq
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Eq
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Eq
	 *     UnaryExpr returns Eq
	 *     UnaryExpr.Cast_0_1_0_0 returns Eq
	 *     MemberExpr returns Eq
	 *     MemberExpr.MemberRef_1_0_0 returns Eq
	 *     PrimaryExpr returns Eq
	 *
	 * Constraint:
	 *     (left=ComparativeExpr_Eq_1_0_0_0 right=AdditiveExpr)
	 */
	protected void sequence_ComparativeExpr(ISerializationContext context, Eq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.EQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.EQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparativeExprAccess().getEqLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparativeExprAccess().getRightAdditiveExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Lt
	 *     IfLetExpr returns Lt
	 *     AssignmentExpr returns Lt
	 *     AssignmentExpr.Assignment_1_0_0 returns Lt
	 *     LogicalOrExpr returns Lt
	 *     LogicalOrExpr.Or_1_0_0 returns Lt
	 *     LogicalAndExpr returns Lt
	 *     LogicalAndExpr.And_1_0_0 returns Lt
	 *     ComparativeExpr returns Lt
	 *     ComparativeExpr.Eq_1_0_0_0 returns Lt
	 *     ComparativeExpr.Neq_1_0_1_0 returns Lt
	 *     ComparativeExpr.Lt_1_0_2_0 returns Lt
	 *     AdditiveExpr returns Lt
	 *     AdditiveExpr.Add_1_0_0_0 returns Lt
	 *     AdditiveExpr.Sub_1_0_1_0 returns Lt
	 *     MultiplicativeExpr returns Lt
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Lt
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Lt
	 *     UnaryExpr returns Lt
	 *     UnaryExpr.Cast_0_1_0_0 returns Lt
	 *     MemberExpr returns Lt
	 *     MemberExpr.MemberRef_1_0_0 returns Lt
	 *     PrimaryExpr returns Lt
	 *
	 * Constraint:
	 *     (left=ComparativeExpr_Lt_1_0_2_0 right=AdditiveExpr)
	 */
	protected void sequence_ComparativeExpr(ISerializationContext context, Lt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.LT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.LT__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.LT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.LT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparativeExprAccess().getLtLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparativeExprAccess().getRightAdditiveExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Neq
	 *     IfLetExpr returns Neq
	 *     AssignmentExpr returns Neq
	 *     AssignmentExpr.Assignment_1_0_0 returns Neq
	 *     LogicalOrExpr returns Neq
	 *     LogicalOrExpr.Or_1_0_0 returns Neq
	 *     LogicalAndExpr returns Neq
	 *     LogicalAndExpr.And_1_0_0 returns Neq
	 *     ComparativeExpr returns Neq
	 *     ComparativeExpr.Eq_1_0_0_0 returns Neq
	 *     ComparativeExpr.Neq_1_0_1_0 returns Neq
	 *     ComparativeExpr.Lt_1_0_2_0 returns Neq
	 *     AdditiveExpr returns Neq
	 *     AdditiveExpr.Add_1_0_0_0 returns Neq
	 *     AdditiveExpr.Sub_1_0_1_0 returns Neq
	 *     MultiplicativeExpr returns Neq
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Neq
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Neq
	 *     UnaryExpr returns Neq
	 *     UnaryExpr.Cast_0_1_0_0 returns Neq
	 *     MemberExpr returns Neq
	 *     MemberExpr.MemberRef_1_0_0 returns Neq
	 *     PrimaryExpr returns Neq
	 *
	 * Constraint:
	 *     (left=ComparativeExpr_Neq_1_0_1_0 right=AdditiveExpr)
	 */
	protected void sequence_ComparativeExpr(ISerializationContext context, Neq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.NEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.NEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.NEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.NEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparativeExprAccess().getNeqLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparativeExprAccess().getRightAdditiveExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Field
	 *     Symbol returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] name=ID)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(PapljPackage.Literals.SYMBOL__TYPE, false));
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns If
	 *     IfLetExpr returns If
	 *     AssignmentExpr returns If
	 *     AssignmentExpr.Assignment_1_0_0 returns If
	 *     LogicalOrExpr returns If
	 *     LogicalOrExpr.Or_1_0_0 returns If
	 *     LogicalAndExpr returns If
	 *     LogicalAndExpr.And_1_0_0 returns If
	 *     ComparativeExpr returns If
	 *     ComparativeExpr.Eq_1_0_0_0 returns If
	 *     ComparativeExpr.Neq_1_0_1_0 returns If
	 *     ComparativeExpr.Lt_1_0_2_0 returns If
	 *     AdditiveExpr returns If
	 *     AdditiveExpr.Add_1_0_0_0 returns If
	 *     AdditiveExpr.Sub_1_0_1_0 returns If
	 *     MultiplicativeExpr returns If
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns If
	 *     MultiplicativeExpr.Div_1_0_1_0 returns If
	 *     UnaryExpr returns If
	 *     UnaryExpr.Cast_0_1_0_0 returns If
	 *     MemberExpr returns If
	 *     MemberExpr.MemberRef_1_0_0 returns If
	 *     PrimaryExpr returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (condition=Expr onTrue=Expr onFalse=Expr)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.IF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.IF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.IF__ON_TRUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.IF__ON_TRUE));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.IF__ON_FALSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.IF__ON_FALSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getConditionExprParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfAccess().getOnTrueExprParserRuleCall_4_0(), semanticObject.getOnTrue());
		feeder.accept(grammarAccess.getIfAccess().getOnFalseExprParserRuleCall_6_0(), semanticObject.getOnFalse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Let
	 *     IfLetExpr returns Let
	 *     AssignmentExpr returns Let
	 *     AssignmentExpr.Assignment_1_0_0 returns Let
	 *     LogicalOrExpr returns Let
	 *     LogicalOrExpr.Or_1_0_0 returns Let
	 *     LogicalAndExpr returns Let
	 *     LogicalAndExpr.And_1_0_0 returns Let
	 *     ComparativeExpr returns Let
	 *     ComparativeExpr.Eq_1_0_0_0 returns Let
	 *     ComparativeExpr.Neq_1_0_1_0 returns Let
	 *     ComparativeExpr.Lt_1_0_2_0 returns Let
	 *     AdditiveExpr returns Let
	 *     AdditiveExpr.Add_1_0_0_0 returns Let
	 *     AdditiveExpr.Sub_1_0_1_0 returns Let
	 *     MultiplicativeExpr returns Let
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Let
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Let
	 *     UnaryExpr returns Let
	 *     UnaryExpr.Cast_0_1_0_0 returns Let
	 *     MemberExpr returns Let
	 *     MemberExpr.MemberRef_1_0_0 returns Let
	 *     PrimaryExpr returns Let
	 *     Let returns Let
	 *
	 * Constraint:
	 *     (bindings+=Binding* expr=Expr)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns And
	 *     IfLetExpr returns And
	 *     AssignmentExpr returns And
	 *     AssignmentExpr.Assignment_1_0_0 returns And
	 *     LogicalOrExpr returns And
	 *     LogicalOrExpr.Or_1_0_0 returns And
	 *     LogicalAndExpr returns And
	 *     LogicalAndExpr.And_1_0_0 returns And
	 *     ComparativeExpr returns And
	 *     ComparativeExpr.Eq_1_0_0_0 returns And
	 *     ComparativeExpr.Neq_1_0_1_0 returns And
	 *     ComparativeExpr.Lt_1_0_2_0 returns And
	 *     AdditiveExpr returns And
	 *     AdditiveExpr.Add_1_0_0_0 returns And
	 *     AdditiveExpr.Sub_1_0_1_0 returns And
	 *     MultiplicativeExpr returns And
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns And
	 *     MultiplicativeExpr.Div_1_0_1_0 returns And
	 *     UnaryExpr returns And
	 *     UnaryExpr.Cast_0_1_0_0 returns And
	 *     MemberExpr returns And
	 *     MemberExpr.MemberRef_1_0_0 returns And
	 *     PrimaryExpr returns And
	 *
	 * Constraint:
	 *     (left=LogicalAndExpr_And_1_0_0 right=ComparativeExpr)
	 */
	protected void sequence_LogicalAndExpr(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalAndExprAccess().getAndLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalAndExprAccess().getRightComparativeExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Or
	 *     IfLetExpr returns Or
	 *     AssignmentExpr returns Or
	 *     AssignmentExpr.Assignment_1_0_0 returns Or
	 *     LogicalOrExpr returns Or
	 *     LogicalOrExpr.Or_1_0_0 returns Or
	 *     LogicalAndExpr returns Or
	 *     LogicalAndExpr.And_1_0_0 returns Or
	 *     ComparativeExpr returns Or
	 *     ComparativeExpr.Eq_1_0_0_0 returns Or
	 *     ComparativeExpr.Neq_1_0_1_0 returns Or
	 *     ComparativeExpr.Lt_1_0_2_0 returns Or
	 *     AdditiveExpr returns Or
	 *     AdditiveExpr.Add_1_0_0_0 returns Or
	 *     AdditiveExpr.Sub_1_0_1_0 returns Or
	 *     MultiplicativeExpr returns Or
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Or
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Or
	 *     UnaryExpr returns Or
	 *     UnaryExpr.Cast_0_1_0_0 returns Or
	 *     MemberExpr returns Or
	 *     MemberExpr.MemberRef_1_0_0 returns Or
	 *     PrimaryExpr returns Or
	 *
	 * Constraint:
	 *     (left=LogicalOrExpr_Or_1_0_0 right=LogicalAndExpr)
	 */
	protected void sequence_LogicalOrExpr(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalOrExprAccess().getOrLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalOrExprAccess().getRightLogicalAndExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns MemberRef
	 *     IfLetExpr returns MemberRef
	 *     AssignmentExpr returns MemberRef
	 *     AssignmentExpr.Assignment_1_0_0 returns MemberRef
	 *     LogicalOrExpr returns MemberRef
	 *     LogicalOrExpr.Or_1_0_0 returns MemberRef
	 *     LogicalAndExpr returns MemberRef
	 *     LogicalAndExpr.And_1_0_0 returns MemberRef
	 *     ComparativeExpr returns MemberRef
	 *     ComparativeExpr.Eq_1_0_0_0 returns MemberRef
	 *     ComparativeExpr.Neq_1_0_1_0 returns MemberRef
	 *     ComparativeExpr.Lt_1_0_2_0 returns MemberRef
	 *     AdditiveExpr returns MemberRef
	 *     AdditiveExpr.Add_1_0_0_0 returns MemberRef
	 *     AdditiveExpr.Sub_1_0_1_0 returns MemberRef
	 *     MultiplicativeExpr returns MemberRef
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns MemberRef
	 *     MultiplicativeExpr.Div_1_0_1_0 returns MemberRef
	 *     UnaryExpr returns MemberRef
	 *     UnaryExpr.Cast_0_1_0_0 returns MemberRef
	 *     MemberExpr returns MemberRef
	 *     MemberExpr.MemberRef_1_0_0 returns MemberRef
	 *     PrimaryExpr returns MemberRef
	 *
	 * Constraint:
	 *     (left=MemberExpr_MemberRef_1_0_0 member=[Member|ID] (methodInvocation?='(' (args+=Expr args+=Expr*)?)?)
	 */
	protected void sequence_MemberExpr(ISerializationContext context, MemberRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Method
	 *     Symbol returns Method
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] name=ID (params+=Param params+=Param*)? body=Block2)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Div
	 *     IfLetExpr returns Div
	 *     AssignmentExpr returns Div
	 *     AssignmentExpr.Assignment_1_0_0 returns Div
	 *     LogicalOrExpr returns Div
	 *     LogicalOrExpr.Or_1_0_0 returns Div
	 *     LogicalAndExpr returns Div
	 *     LogicalAndExpr.And_1_0_0 returns Div
	 *     ComparativeExpr returns Div
	 *     ComparativeExpr.Eq_1_0_0_0 returns Div
	 *     ComparativeExpr.Neq_1_0_1_0 returns Div
	 *     ComparativeExpr.Lt_1_0_2_0 returns Div
	 *     AdditiveExpr returns Div
	 *     AdditiveExpr.Add_1_0_0_0 returns Div
	 *     AdditiveExpr.Sub_1_0_1_0 returns Div
	 *     MultiplicativeExpr returns Div
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Div
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Div
	 *     UnaryExpr returns Div
	 *     UnaryExpr.Cast_0_1_0_0 returns Div
	 *     MemberExpr returns Div
	 *     MemberExpr.MemberRef_1_0_0 returns Div
	 *     PrimaryExpr returns Div
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpr_Div_1_0_1_0 right=UnaryExpr)
	 */
	protected void sequence_MultiplicativeExpr(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getRightUnaryExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Mul
	 *     IfLetExpr returns Mul
	 *     AssignmentExpr returns Mul
	 *     AssignmentExpr.Assignment_1_0_0 returns Mul
	 *     LogicalOrExpr returns Mul
	 *     LogicalOrExpr.Or_1_0_0 returns Mul
	 *     LogicalAndExpr returns Mul
	 *     LogicalAndExpr.And_1_0_0 returns Mul
	 *     ComparativeExpr returns Mul
	 *     ComparativeExpr.Eq_1_0_0_0 returns Mul
	 *     ComparativeExpr.Neq_1_0_1_0 returns Mul
	 *     ComparativeExpr.Lt_1_0_2_0 returns Mul
	 *     AdditiveExpr returns Mul
	 *     AdditiveExpr.Add_1_0_0_0 returns Mul
	 *     AdditiveExpr.Sub_1_0_1_0 returns Mul
	 *     MultiplicativeExpr returns Mul
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Mul
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Mul
	 *     UnaryExpr returns Mul
	 *     UnaryExpr.Cast_0_1_0_0 returns Mul
	 *     MemberExpr returns Mul
	 *     MemberExpr.MemberRef_1_0_0 returns Mul
	 *     PrimaryExpr returns Mul
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpr_Mul_1_0_0_0 right=UnaryExpr)
	 */
	protected void sequence_MultiplicativeExpr(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getRightUnaryExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Param
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] name=ID)
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getTypeTypeQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(PapljPackage.Literals.SYMBOL__TYPE, false));
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Bool
	 *     IfLetExpr returns Bool
	 *     AssignmentExpr returns Bool
	 *     AssignmentExpr.Assignment_1_0_0 returns Bool
	 *     LogicalOrExpr returns Bool
	 *     LogicalOrExpr.Or_1_0_0 returns Bool
	 *     LogicalAndExpr returns Bool
	 *     LogicalAndExpr.And_1_0_0 returns Bool
	 *     ComparativeExpr returns Bool
	 *     ComparativeExpr.Eq_1_0_0_0 returns Bool
	 *     ComparativeExpr.Neq_1_0_1_0 returns Bool
	 *     ComparativeExpr.Lt_1_0_2_0 returns Bool
	 *     AdditiveExpr returns Bool
	 *     AdditiveExpr.Add_1_0_0_0 returns Bool
	 *     AdditiveExpr.Sub_1_0_1_0 returns Bool
	 *     MultiplicativeExpr returns Bool
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Bool
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Bool
	 *     UnaryExpr returns Bool
	 *     UnaryExpr.Cast_0_1_0_0 returns Bool
	 *     MemberExpr returns Bool
	 *     MemberExpr.MemberRef_1_0_0 returns Bool
	 *     PrimaryExpr returns Bool
	 *
	 * Constraint:
	 *     true?='true'?
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns New
	 *     IfLetExpr returns New
	 *     AssignmentExpr returns New
	 *     AssignmentExpr.Assignment_1_0_0 returns New
	 *     LogicalOrExpr returns New
	 *     LogicalOrExpr.Or_1_0_0 returns New
	 *     LogicalAndExpr returns New
	 *     LogicalAndExpr.And_1_0_0 returns New
	 *     ComparativeExpr returns New
	 *     ComparativeExpr.Eq_1_0_0_0 returns New
	 *     ComparativeExpr.Neq_1_0_1_0 returns New
	 *     ComparativeExpr.Lt_1_0_2_0 returns New
	 *     AdditiveExpr returns New
	 *     AdditiveExpr.Add_1_0_0_0 returns New
	 *     AdditiveExpr.Sub_1_0_1_0 returns New
	 *     MultiplicativeExpr returns New
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns New
	 *     MultiplicativeExpr.Div_1_0_1_0 returns New
	 *     UnaryExpr returns New
	 *     UnaryExpr.Cast_0_1_0_0 returns New
	 *     MemberExpr returns New
	 *     MemberExpr.MemberRef_1_0_0 returns New
	 *     PrimaryExpr returns New
	 *
	 * Constraint:
	 *     type=[Type|QualifiedName]
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, New semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.NEW__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.NEW__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getTypeTypeQualifiedNameParserRuleCall_4_2_0_1(), semanticObject.eGet(PapljPackage.Literals.NEW__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Null
	 *     IfLetExpr returns Null
	 *     AssignmentExpr returns Null
	 *     AssignmentExpr.Assignment_1_0_0 returns Null
	 *     LogicalOrExpr returns Null
	 *     LogicalOrExpr.Or_1_0_0 returns Null
	 *     LogicalAndExpr returns Null
	 *     LogicalAndExpr.And_1_0_0 returns Null
	 *     ComparativeExpr returns Null
	 *     ComparativeExpr.Eq_1_0_0_0 returns Null
	 *     ComparativeExpr.Neq_1_0_1_0 returns Null
	 *     ComparativeExpr.Lt_1_0_2_0 returns Null
	 *     AdditiveExpr returns Null
	 *     AdditiveExpr.Add_1_0_0_0 returns Null
	 *     AdditiveExpr.Sub_1_0_1_0 returns Null
	 *     MultiplicativeExpr returns Null
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Null
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Null
	 *     UnaryExpr returns Null
	 *     UnaryExpr.Cast_0_1_0_0 returns Null
	 *     MemberExpr returns Null
	 *     MemberExpr.MemberRef_1_0_0 returns Null
	 *     PrimaryExpr returns Null
	 *
	 * Constraint:
	 *     type=[Type|ID]?
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Null semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Num
	 *     IfLetExpr returns Num
	 *     AssignmentExpr returns Num
	 *     AssignmentExpr.Assignment_1_0_0 returns Num
	 *     LogicalOrExpr returns Num
	 *     LogicalOrExpr.Or_1_0_0 returns Num
	 *     LogicalAndExpr returns Num
	 *     LogicalAndExpr.And_1_0_0 returns Num
	 *     ComparativeExpr returns Num
	 *     ComparativeExpr.Eq_1_0_0_0 returns Num
	 *     ComparativeExpr.Neq_1_0_1_0 returns Num
	 *     ComparativeExpr.Lt_1_0_2_0 returns Num
	 *     AdditiveExpr returns Num
	 *     AdditiveExpr.Add_1_0_0_0 returns Num
	 *     AdditiveExpr.Sub_1_0_1_0 returns Num
	 *     MultiplicativeExpr returns Num
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Num
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Num
	 *     UnaryExpr returns Num
	 *     UnaryExpr.Cast_0_1_0_0 returns Num
	 *     MemberExpr returns Num
	 *     MemberExpr.MemberRef_1_0_0 returns Num
	 *     PrimaryExpr returns Num
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Num semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.NUM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.NUM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns This
	 *     IfLetExpr returns This
	 *     AssignmentExpr returns This
	 *     AssignmentExpr.Assignment_1_0_0 returns This
	 *     LogicalOrExpr returns This
	 *     LogicalOrExpr.Or_1_0_0 returns This
	 *     LogicalAndExpr returns This
	 *     LogicalAndExpr.And_1_0_0 returns This
	 *     ComparativeExpr returns This
	 *     ComparativeExpr.Eq_1_0_0_0 returns This
	 *     ComparativeExpr.Neq_1_0_1_0 returns This
	 *     ComparativeExpr.Lt_1_0_2_0 returns This
	 *     AdditiveExpr returns This
	 *     AdditiveExpr.Add_1_0_0_0 returns This
	 *     AdditiveExpr.Sub_1_0_1_0 returns This
	 *     MultiplicativeExpr returns This
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns This
	 *     MultiplicativeExpr.Div_1_0_1_0 returns This
	 *     UnaryExpr returns This
	 *     UnaryExpr.Cast_0_1_0_0 returns This
	 *     MemberExpr returns This
	 *     MemberExpr.MemberRef_1_0_0 returns This
	 *     PrimaryExpr returns This
	 *
	 * Constraint:
	 *     {This}
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Var
	 *     IfLetExpr returns Var
	 *     AssignmentExpr returns Var
	 *     AssignmentExpr.Assignment_1_0_0 returns Var
	 *     LogicalOrExpr returns Var
	 *     LogicalOrExpr.Or_1_0_0 returns Var
	 *     LogicalAndExpr returns Var
	 *     LogicalAndExpr.And_1_0_0 returns Var
	 *     ComparativeExpr returns Var
	 *     ComparativeExpr.Eq_1_0_0_0 returns Var
	 *     ComparativeExpr.Neq_1_0_1_0 returns Var
	 *     ComparativeExpr.Lt_1_0_2_0 returns Var
	 *     AdditiveExpr returns Var
	 *     AdditiveExpr.Add_1_0_0_0 returns Var
	 *     AdditiveExpr.Sub_1_0_1_0 returns Var
	 *     MultiplicativeExpr returns Var
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Var
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Var
	 *     UnaryExpr returns Var
	 *     UnaryExpr.Cast_0_1_0_0 returns Var
	 *     MemberExpr returns Var
	 *     MemberExpr.MemberRef_1_0_0 returns Var
	 *     PrimaryExpr returns Var
	 *
	 * Constraint:
	 *     (member=[Symbol|ID] (methodInvocation?='(' (args+=Expr args+=Expr*)?)?)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName ((imports+=Import+ expr=Expr) | expr=Expr)) | 
	 *         (((name=QualifiedName imports+=Import+) | imports+=Import+)? classes+=Type+ expr=Expr) | 
	 *         (imports+=Import+ expr=Expr) | 
	 *         expr=Expr
	 *     )?
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (name=ID superType=[Type|QualifiedName]? members+=Member*)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Cast
	 *     IfLetExpr returns Cast
	 *     AssignmentExpr returns Cast
	 *     AssignmentExpr.Assignment_1_0_0 returns Cast
	 *     LogicalOrExpr returns Cast
	 *     LogicalOrExpr.Or_1_0_0 returns Cast
	 *     LogicalAndExpr returns Cast
	 *     LogicalAndExpr.And_1_0_0 returns Cast
	 *     ComparativeExpr returns Cast
	 *     ComparativeExpr.Eq_1_0_0_0 returns Cast
	 *     ComparativeExpr.Neq_1_0_1_0 returns Cast
	 *     ComparativeExpr.Lt_1_0_2_0 returns Cast
	 *     AdditiveExpr returns Cast
	 *     AdditiveExpr.Add_1_0_0_0 returns Cast
	 *     AdditiveExpr.Sub_1_0_1_0 returns Cast
	 *     MultiplicativeExpr returns Cast
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Cast
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Cast
	 *     UnaryExpr returns Cast
	 *     UnaryExpr.Cast_0_1_0_0 returns Cast
	 *     MemberExpr returns Cast
	 *     MemberExpr.MemberRef_1_0_0 returns Cast
	 *     PrimaryExpr returns Cast
	 *
	 * Constraint:
	 *     (left=UnaryExpr_Cast_0_1_0_0 type=[Type|ID])
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, Cast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.CAST__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.CAST__LEFT));
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.CAST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.CAST__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getCastLeftAction_0_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getUnaryExprAccess().getTypeTypeIDTerminalRuleCall_0_1_1_0_1(), semanticObject.eGet(PapljPackage.Literals.CAST__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Min
	 *     IfLetExpr returns Min
	 *     AssignmentExpr returns Min
	 *     AssignmentExpr.Assignment_1_0_0 returns Min
	 *     LogicalOrExpr returns Min
	 *     LogicalOrExpr.Or_1_0_0 returns Min
	 *     LogicalAndExpr returns Min
	 *     LogicalAndExpr.And_1_0_0 returns Min
	 *     ComparativeExpr returns Min
	 *     ComparativeExpr.Eq_1_0_0_0 returns Min
	 *     ComparativeExpr.Neq_1_0_1_0 returns Min
	 *     ComparativeExpr.Lt_1_0_2_0 returns Min
	 *     AdditiveExpr returns Min
	 *     AdditiveExpr.Add_1_0_0_0 returns Min
	 *     AdditiveExpr.Sub_1_0_1_0 returns Min
	 *     MultiplicativeExpr returns Min
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Min
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Min
	 *     UnaryExpr returns Min
	 *     UnaryExpr.Cast_0_1_0_0 returns Min
	 *     MemberExpr returns Min
	 *     MemberExpr.MemberRef_1_0_0 returns Min
	 *     PrimaryExpr returns Min
	 *
	 * Constraint:
	 *     expr=UnaryExpr
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, Min semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.MIN__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.MIN__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getExprUnaryExprParserRuleCall_2_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Not
	 *     IfLetExpr returns Not
	 *     AssignmentExpr returns Not
	 *     AssignmentExpr.Assignment_1_0_0 returns Not
	 *     LogicalOrExpr returns Not
	 *     LogicalOrExpr.Or_1_0_0 returns Not
	 *     LogicalAndExpr returns Not
	 *     LogicalAndExpr.And_1_0_0 returns Not
	 *     ComparativeExpr returns Not
	 *     ComparativeExpr.Eq_1_0_0_0 returns Not
	 *     ComparativeExpr.Neq_1_0_1_0 returns Not
	 *     ComparativeExpr.Lt_1_0_2_0 returns Not
	 *     AdditiveExpr returns Not
	 *     AdditiveExpr.Add_1_0_0_0 returns Not
	 *     AdditiveExpr.Sub_1_0_1_0 returns Not
	 *     MultiplicativeExpr returns Not
	 *     MultiplicativeExpr.Mul_1_0_0_0 returns Not
	 *     MultiplicativeExpr.Div_1_0_1_0 returns Not
	 *     UnaryExpr returns Not
	 *     UnaryExpr.Cast_0_1_0_0 returns Not
	 *     MemberExpr returns Not
	 *     MemberExpr.MemberRef_1_0_0 returns Not
	 *     PrimaryExpr returns Not
	 *
	 * Constraint:
	 *     expr=UnaryExpr
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PapljPackage.Literals.NOT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PapljPackage.Literals.NOT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getExprUnaryExprParserRuleCall_1_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
}
