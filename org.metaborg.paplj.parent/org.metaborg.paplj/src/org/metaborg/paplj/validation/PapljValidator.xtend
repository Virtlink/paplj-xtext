/*
 * generated by Xtext 2.10.0
 */
package org.metaborg.paplj.validation

import com.google.inject.Inject
import org.metaborg.paplj.types.PapljTypeProvider
import org.metaborg.paplj.types.PapljTypeConformance
import org.metaborg.paplj.paplj.Expr
import org.eclipse.xtext.validation.Check
import org.metaborg.paplj.paplj.PapljPackage
import org.metaborg.paplj.paplj.*
import static extension org.metaborg.paplj.PapljModelUtil.*;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PapljValidator extends AbstractPapljValidator {
	
	@Inject extension PapljTypeProvider
	@Inject extension PapljTypeConformance
	
	// These are identifiers, but do not have to be real classes.
	public static val INCOMPATIBLE_TYPES = "org.metaborg.paplj.IncompatibleTypes"
	public static val HIERARCHY_CYCLE = "org.metaborg.paplj.HierarchyCycle"
	
	@Check
	def void checkCompatibleTypes(Expr e) {
		val actualType = e.typeOf
		val expectedType = e.expectedTypeOf
		if (expectedType === null || actualType === null)
			return;
		if (!actualType.isConformant(expectedType)) {
			error('''Incompatible types. Expected '«expectedType?.name»'
			but was '«actualType?.name»'.''',
			null, INCOMPATIBLE_TYPES)
		}
	}
	
	@Check
	def checkTypeHierarchy(Type c) {
		if (c.ancestors.contains(c)) {
			error('''Cycle in hierarchy of type '«c.name»'.''',
			PapljPackage::eINSTANCE.type_SuperType, HIERARCHY_CYCLE, c.superType.name)
		}
	}
	
}
