/**
 * generated by Xtext 2.10.0
 */
package org.metaborg.paplj.validation;

import com.google.inject.Inject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.metaborg.paplj.PapljModelUtil;
import org.metaborg.paplj.paplj.Expr;
import org.metaborg.paplj.paplj.PapljPackage;
import org.metaborg.paplj.paplj.Type;
import org.metaborg.paplj.types.PapljTypeConformance;
import org.metaborg.paplj.types.PapljTypeProvider;
import org.metaborg.paplj.validation.AbstractPapljValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class PapljValidator extends AbstractPapljValidator {
  @Inject
  @Extension
  private PapljTypeProvider _papljTypeProvider;
  
  @Inject
  @Extension
  private PapljTypeConformance _papljTypeConformance;
  
  public final static String INCOMPATIBLE_TYPES = "org.metaborg.paplj.IncompatibleTypes";
  
  public final static String HIERARCHY_CYCLE = "org.metaborg.paplj.HierarchyCycle";
  
  @Check
  public void checkCompatibleTypes(final Expr e) {
    final Type actualType = this._papljTypeProvider.typeOf(e);
    final Type expectedType = this._papljTypeProvider.expectedTypeOf(e);
    if (((expectedType == null) || (actualType == null))) {
      return;
    }
    boolean _isConformant = this._papljTypeConformance.isConformant(actualType, expectedType);
    boolean _not = (!_isConformant);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Incompatible types. Expected \'");
      String _name = null;
      if (expectedType!=null) {
        _name=expectedType.getName();
      }
      _builder.append(_name);
      _builder.append("\'");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t\t");
      _builder.append("but was \'");
      String _name_1 = null;
      if (actualType!=null) {
        _name_1=actualType.getName();
      }
      _builder.append(_name_1, "\t\t\t");
      _builder.append("\'.");
      this.error(_builder.toString(), 
        null, PapljValidator.INCOMPATIBLE_TYPES);
    }
  }
  
  @Check
  public void checkTypeHierarchy(final Type c) {
    boolean _contains = PapljModelUtil.ancestors(c).contains(c);
    if (_contains) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Cycle in hierarchy of type \'");
      String _name = c.getName();
      _builder.append(_name);
      _builder.append("\'.");
      this.error(_builder.toString(), 
        PapljPackage.eINSTANCE.getType_SuperType(), PapljValidator.HIERARCHY_CYCLE, c.getSuperType().getName());
    }
  }
}
