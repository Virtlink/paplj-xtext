/**
 * generated by Xtext 2.10.0
 */
package org.metaborg.paplj.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.metaborg.paplj.PapljModelUtil;
import org.metaborg.paplj.lib.PapljLib;
import org.metaborg.paplj.paplj.Binding;
import org.metaborg.paplj.paplj.Block2;
import org.metaborg.paplj.paplj.Expr;
import org.metaborg.paplj.paplj.Field;
import org.metaborg.paplj.paplj.Let;
import org.metaborg.paplj.paplj.Member;
import org.metaborg.paplj.paplj.MemberRef;
import org.metaborg.paplj.paplj.Method;
import org.metaborg.paplj.paplj.PapljPackage;
import org.metaborg.paplj.paplj.Type;
import org.metaborg.paplj.paplj.Var;
import org.metaborg.paplj.scoping.AbstractPapljScopeProvider;
import org.metaborg.paplj.types.PapljTypeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class PapljScopeProvider extends AbstractPapljScopeProvider {
  @Inject
  @Extension
  private PapljTypeProvider _papljTypeProvider;
  
  @Inject
  @Extension
  private PapljLib _papljLib;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof MemberRef) {
      boolean _equals = Objects.equal(reference, PapljPackage.Literals.MEMBER_REF__MEMBER);
      if (_equals) {
        _matched=true;
        _switchResult = this.scope_MemberRef_member(((MemberRef)context), reference);
      }
    }
    if (!_matched) {
      _switchResult = super.getScope(context, reference);
    }
    return _switchResult;
  }
  
  public IScope scope_MemberRef_member(final MemberRef ref, final EReference r) {
    IScope _xblockexpression = null;
    {
      final Type type = this._papljTypeProvider.typeOf(ref.getLeft());
      final IScope scope = this.getScopesForClasses(IScope.NULLSCOPE, type, ref.isMethodInvocation());
      _xblockexpression = scope;
    }
    return _xblockexpression;
  }
  
  public IScope scope_Var_member(final Var ref, final EReference r) {
    IScope _xblockexpression = null;
    {
      final Type type = EcoreUtil2.<Type>getContainerOfType(ref, Type.class);
      final IScope scope = this.getScopesForClasses(IScope.NULLSCOPE, type, ref.isMethodInvocation());
      final IScope newScope = this.getScopesForBindings(scope, ref);
      _xblockexpression = newScope;
    }
    return _xblockexpression;
  }
  
  public IScope getScopesForClasses(final IScope baseScope, final Type type, final boolean isMethodInvocation) {
    IScope _xblockexpression = null;
    {
      IScope scope = baseScope;
      if (((type == null) || this._papljTypeProvider.isPrimitive(type))) {
        return scope;
      }
      List<Type> _reverseView = ListExtensions.<Type>reverseView(PapljModelUtil.ancestors(type));
      for (final Type c : _reverseView) {
        scope = Scopes.scopeFor(this.selectMembers(c, isMethodInvocation), scope);
      }
      _xblockexpression = Scopes.scopeFor(this.selectMembers(type, isMethodInvocation), scope);
    }
    return _xblockexpression;
  }
  
  public Iterable<Member> selectMembers(final Type type, final boolean isMethodInvocation) {
    Iterable<Member> _xifexpression = null;
    if (isMethodInvocation) {
      Iterable<Method> _methods = PapljModelUtil.methods(type);
      Iterable<Field> _fields = PapljModelUtil.fields(type);
      _xifexpression = Iterables.<Member>concat(_methods, _fields);
    } else {
      Iterable<Field> _fields_1 = PapljModelUtil.fields(type);
      Iterable<Method> _methods_1 = PapljModelUtil.methods(type);
      _xifexpression = Iterables.<Member>concat(_fields_1, _methods_1);
    }
    return _xifexpression;
  }
  
  protected IScope _symbolsDefinedBefore(final EObject container, final EObject o) {
    return this.symbolsDefinedBefore(container.eContainer(), o.eContainer());
  }
  
  protected IScope _symbolsDefinedBefore(final Method m, final EObject o) {
    return Scopes.scopeFor(m.getParams());
  }
  
  protected IScope _symbolsDefinedBefore(final Block2 b, final EObject o) {
    return Scopes.scopeFor(this.variablesDeclaredBefore(b.getExprs(), o), this.symbolsDefinedBefore(b.eContainer(), o.eContainer()));
  }
  
  private ArrayList<EObject> variablesDeclaredBefore(final List<Expr> list, final EObject o) {
    return CollectionLiterals.<EObject>newArrayList();
  }
  
  public IScope getScopesForBindings(final IScope baseScope, final Expr e) {
    IScope _xblockexpression = null;
    {
      IScope scope = baseScope;
      if ((e == null)) {
        return scope;
      }
      List<Let> _reverseView = ListExtensions.<Let>reverseView(PapljModelUtil.lets(e));
      for (final Let l : _reverseView) {
        scope = Scopes.scopeFor(this.selectBindings(l), scope);
      }
      _xblockexpression = scope;
    }
    return _xblockexpression;
  }
  
  public EList<Binding> selectBindings(final Let let) {
    return let.getBindings();
  }
  
  public IScope symbolsDefinedBefore(final EObject m, final EObject o) {
    if (m instanceof Method) {
      return _symbolsDefinedBefore((Method)m, o);
    } else if (m instanceof Block2) {
      return _symbolsDefinedBefore((Block2)m, o);
    } else if (m != null) {
      return _symbolsDefinedBefore(m, o);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m, o).toString());
    }
  }
}
